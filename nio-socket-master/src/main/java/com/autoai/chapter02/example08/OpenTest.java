package com.autoai.chapter02.example08;

import lombok.extern.slf4j.Slf4j;
import org.junit.Test;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.OpenOption;
import java.nio.file.StandardOpenOption;

/**
 * @Author: zhukaishengy
 * @Date: 2020/6/2 14:11
 * @Description:
 */
@Slf4j
public class OpenTest {

    /**
     * <p>枚举常量CREATE
     * 此选项只是一个创建文件的意图，并不能真正地创建文件，因此，CREATE不能单独使用，那样就会出现java.nio.file.NoSuchFileException异常。
     * @throws IOException
     */
    @Test
    public void test1() throws IOException {
        File file = new File("/Users/zhukaishengy/StudyWorkSpace/nio-socket/src/main/java/com/autoai/chapter02/file/l.txt");
        FileChannel channel = FileChannel.open(file.toPath(), StandardOpenOption.CREATE);
        channel.close();
    }

    /**
     * 创建文件，结合WRITE常量
     * @throws IOException
     */
    @Test
    public void test2() throws IOException {
        File file = new File("/Users/zhukaishengy/StudyWorkSpace/nio-socket/src/main/java/com/autoai/chapter02/file/l.txt");
        FileChannel channel = FileChannel.open(file.toPath(), StandardOpenOption.CREATE, StandardOpenOption.WRITE);
        channel.close();
    }

    /**
     * 枚举常量APPEND的使用
     *
     * 如果打开文件以进行写入访问，则字节将写入文件末尾而不是开始处。
     * @throws IOException
     */
    @Test
    public void test3() throws IOException {
        File file = new File("/Users/zhukaishengy/StudyWorkSpace/nio-socket/src/main/java/com/autoai/chapter02/file/l.txt");
        // 向文件中写入一些数据
        RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rw");
        FileChannel channel = randomAccessFile.getChannel();
        channel.write(ByteBuffer.wrap("abc".getBytes()));
        channel.close();
        // 测试 枚举常量APPEND的使用
        FileChannel channel1 = FileChannel.open(file.toPath(), StandardOpenOption.APPEND);
        channel1.write(ByteBuffer.wrap("def".getBytes()));
        channel1.close();
    }

    /**
     * 枚举常量READ的使用
     *
     * 打开以进行读取访问。
     * @throws IOException
     */
    @Test
    public void test4() throws IOException {
        File file = new File("/Users/zhukaishengy/StudyWorkSpace/nio-socket/src/main/java/com/autoai/chapter02/file/l.txt");
        FileChannel channel = FileChannel.open(file.toPath(), StandardOpenOption.READ);
        ByteBuffer byteBuffer = ByteBuffer.allocate(6);
        channel.read(byteBuffer);
        log.info("result:{}", new String(byteBuffer.array()));
        channel.close();
    }

    /**
     * 枚举常量TRUNCATE_EXISTING的使用，结合WRITE常量
     *
     * 如果该文件已存在并且为写入访问而打开，则其长度将被截断为0。如果只为读取访问打开文件，则忽略此选项。
     * @throws IOException
     */
    @Test
    public void test5() throws IOException {
        File file = new File("/Users/zhukaishengy/StudyWorkSpace/nio-socket/src/main/java/com/autoai/chapter02/file/l.txt");
        FileChannel channel = FileChannel.open(file.toPath(), StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE);
        channel.close();
    }

    /**
     * 枚举常量CREATE_NEW的使用，依然需要结合WRITE常量
     * @throws IOException
     */
    @Test
    public void test6() throws IOException {
        File file = new File("/Users/zhukaishengy/StudyWorkSpace/nio-socket/src/main/java/com/autoai/chapter02/file/l.txt");
        FileChannel channel = FileChannel.open(file.toPath(), StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE);
        channel.close();
    }

    /**
     * 枚举常量DELETE_ON_CLOSE的使用
     * @throws IOException
     */
    @Test
    public void test7() throws IOException, InterruptedException {
        File file = new File("/Users/zhukaishengy/StudyWorkSpace/nio-socket/src/main/java/com/autoai/chapter02/file/m.txt");
        FileChannel channel = FileChannel.open(file.toPath(), StandardOpenOption.CREATE, StandardOpenOption.WRITE,
                StandardOpenOption.DELETE_ON_CLOSE);
        Thread.sleep(10000);
        channel.close();
    }

    /**
     * 枚举常量SPARSE的使用
     * 对那些不存储数据的空间不让其占用硬盘容量，等以后写入有效的数据时再占用硬盘容量，这样就达到了提高硬盘空间利用率的目的，这个需求可以通过创建1个“稀疏文件”进行实现。
     * MacOs 上测试不出来
     */
    @Test
    public void test8() throws IOException {

        RandomAccessFile randomAccessFile = new RandomAccessFile("/Users/zhukaishengy/StudyWorkSpace/nio-socket/src/main/java/com/autoai/chapter02/file/m.txt", "rw");
        FileChannel channel = randomAccessFile.getChannel();
        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 3L * 1024 * 1024);
        mappedByteBuffer.position(mappedByteBuffer.capacity() - 3);
        mappedByteBuffer.put("abc".getBytes());
        channel.close();
        randomAccessFile.close();
    }

    @Test
    public void test9() throws IOException {

        File file = new File("/Users/zhukaishengy/StudyWorkSpace/nio-socket/src/main/java/com/autoai/chapter02/file/m.txt");
        FileChannel fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.SPARSE, StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE);

        fileChannel.position(3 * 1024 * 1024 - 3);
        ByteBuffer byteBuffer = ByteBuffer.wrap("abc".getBytes());
        fileChannel.write(byteBuffer);
        fileChannel.close();
    }

    /**
     * 枚举常量SYNC的使用
     * 2020-06-02 19:29:47 [INFO] duration:68
     * 2020-06-02 19:29:48 [INFO] duration:584
     * @throws IOException
     */
    @Test
    public void test10() throws IOException {

        File file = new File("/Users/zhukaishengy/StudyWorkSpace/nio-socket/src/main/java/com/autoai/chapter02/file/m.txt");
        FileChannel fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE, StandardOpenOption.DELETE_ON_CLOSE);

        long begin = System.currentTimeMillis();
        for (int i = 0; i < 5000; i++) {
            fileChannel.write(ByteBuffer.wrap("abc".getBytes()));
        }
        long end = System.currentTimeMillis();
        log.info("duration:{}", end - begin);
        fileChannel.close();

        fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE, StandardOpenOption.SYNC, StandardOpenOption.DELETE_ON_CLOSE);

        begin = System.currentTimeMillis();
        for (int i = 0; i < 5000; i++) {
            fileChannel.write(ByteBuffer.wrap("abc".getBytes()));
        }
        end = System.currentTimeMillis();
        log.info("duration:{}", end - begin);
        fileChannel.close();
    }
}
